name: Common Deployment Tasks (Reusable)

on:
  workflow_call:
    inputs:
      environment:
        description: "Environment name (e.g., pr-123, stg, prod)"
        required: true
        type: string
      image_uri:
        description: "Docker image URI to deploy"
        required: true
        type: string
      tf_workspace:
        description: "Terraform workspace name"
        required: true
        type: string
      is_ephemeral:
        description: "Whether this is an ephemeral environment"
        required: false
        type: boolean
        default: false
      pr_number:
        description: "PR number for ephemeral environments"
        required: false
        type: number
      comment_on_pr:
        description: "Whether to comment deployment URL on PR"
        required: false
        type: boolean
        default: false
      deployment_description:
        description: "Description for deployment record"
        required: false
        type: string
        default: "Deployment"
    outputs:
      environment_url:
        description: "The deployed environment URL"
        value: ${{ jobs.post_deploy.outputs.environment_url }}

permissions:
  id-token: write
  contents: read
  deployments: write

env:
  AWS_REGION: us-east-1
  AWS_ROLE_ARN: arn:aws:iam::655593807337:role/github-actions-calendar-api

jobs:
  # Deploy infrastructure
  deploy:
    name: Deploy Infrastructure
    uses: ./.github/workflows/terraform-deployment.yml
    with:
      environment_name: ${{ inputs.environment }}
      tf_action: apply
      tf_workspace: ${{ inputs.tf_workspace }}
      container_image_uri: ${{ inputs.image_uri }}
      terraform_directory: ./terraform
      pr_number: ${{ inputs.pr_number }}
    secrets:
      AWS_ROLE_TO_ASSUME: ${{ vars.AWS_ROLE_ARN || 'arn:aws:iam::655593807337:role/github-actions-calendar-api' }}
      DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}

  # Run database migrations
  migrate:
    name: Run Database Migrations
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run Migration Task
        run: |
          CLUSTER="calendar-api-${{ inputs.tf_workspace }}"
          TASK_DEFINITION="calendar-api-${{ inputs.tf_workspace }}-migration"

          # Get subnet IDs from the VPC
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=calendar-api-${{ inputs.tf_workspace }}-vpc" --query "Vpcs[0].VpcId" --output text)
          SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" "Name=tag:Name,Values=*private*" --query "Subnets[*].SubnetId" --output text | tr '\t' ',')

          # Get security group ID
          SECURITY_GROUP=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=calendar-api-${{ inputs.tf_workspace }}-ecs-tasks-*" --query "SecurityGroups[0].GroupId" --output text)

          echo "Running database migration task..."
          TASK_ARN=$(aws ecs run-task \
            --cluster $CLUSTER \
            --task-definition $TASK_DEFINITION \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --query "tasks[0].taskArn" \
            --output text)

          echo "Migration task started: $TASK_ARN"
          echo "Waiting for migration to complete..."

          # Wait for task to complete
          aws ecs wait tasks-stopped --cluster $CLUSTER --tasks $TASK_ARN

          # Check task exit status
          EXIT_CODE=$(aws ecs describe-tasks --cluster $CLUSTER --tasks $TASK_ARN --query "tasks[0].containers[0].exitCode" --output text)

          if [ "$EXIT_CODE" != "0" ]; then
            echo "Migration failed with exit code: $EXIT_CODE"
            echo "Fetching logs..."

            # Get log stream name
            TASK_ID=$(echo $TASK_ARN | rev | cut -d'/' -f1 | rev)
            LOG_STREAM="migration/migration/$TASK_ID"

            # Fetch recent logs
            aws logs get-log-events \
              --log-group-name "/ecs/calendar-api-${{ inputs.tf_workspace }}" \
              --log-stream-name "$LOG_STREAM" \
              --start-from-head \
              --limit 100 \
              --query "events[*].message" \
              --output text

            exit 1
          fi

          echo "Migration completed successfully!"

  # Common post deployment tasks
  post_deploy:
    name: Post Deployment Tasks
    needs: [deploy, migrate]
    runs-on: ubuntu-latest
    outputs:
      environment_url: ${{ steps.get_url.outputs.url }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS Service
        run: |
          CLUSTER="calendar-api-${{ inputs.tf_workspace }}"

          # Only force new deployment if the service exists and is stable
          if aws ecs describe-services --cluster $CLUSTER --services calendar-api --query 'services[0].status' --output text | grep -q "ACTIVE"; then
            echo "Waiting for any existing deployments to complete..."
            aws ecs wait services-stable \
              --cluster $CLUSTER \
              --services calendar-api \
              --region ${{ env.AWS_REGION }} || true

            echo "Forcing new deployment..."
            aws ecs update-service \
              --cluster $CLUSTER \
              --service calendar-api \
              --force-new-deployment

            echo "Waiting for service to stabilize..."
            aws ecs wait services-stable \
              --cluster $CLUSTER \
              --services calendar-api \
              --region ${{ env.AWS_REGION }} || echo "Service stabilization timeout"
          else
            echo "Service not active yet, skipping forced deployment"
          fi

      - name: Get environment URL
        id: get_url
        run: |
          ALB_NAME="calendar-api-${{ inputs.tf_workspace }}"
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names $ALB_NAME \
            --query "LoadBalancers[0].DNSName" \
            --output text 2>/dev/null || echo "")

          if [[ "$ALB_DNS" != "" && "$ALB_DNS" != "None" ]]; then
            # Use HTTPS for production, HTTP for others
            PROTOCOL="http"
            if [[ "${{ inputs.environment }}" == "prod" ]]; then
              PROTOCOL="https"
            fi
            echo "url=${PROTOCOL}://$ALB_DNS" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment record
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const env = '${{ inputs.environment }}';
            const isProduction = env === 'prod';
            const isTransient = '${{ inputs.is_ephemeral }}' === 'true';

            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              task: 'deploy',
              auto_merge: false,
              required_contexts: [],
              environment: env,
              description: '${{ inputs.deployment_description }}',
              transient_environment: isTransient,
              production_environment: isProduction
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: '${{ steps.get_url.outputs.url }}',
              description: 'Deployment completed successfully'
            });
