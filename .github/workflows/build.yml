name: Build and Push Docker Image

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  contents: read
  pull-requests: read
  id-token: write  # Required for AWS OIDC

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: calendar-api
  AWS_ROLE_ARN: arn:aws:iam::655593807337:role/github-actions-calendar-api

jobs:
  determine-tag:
    name: Determine Docker Tags
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    outputs:
      tags: ${{ steps.tags.outputs.tags }}
      version: ${{ steps.version.outputs.version }}
      should_deploy: ${{ steps.tags.outputs.should_deploy }}
      environment: ${{ steps.tags.outputs.environment }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for branch detection

      - name: Extract version from pyproject.toml
        id: version
        run: |
          VERSION=$(grep -E '^version = ".*"$' pyproject.toml | sed 's/version = "\(.*\)"/\1/')
          echo "Version found: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials for ECR query
        if: contains(github.ref, 'release/')
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine tags and deployment
        id: tags
        run: |
          BASE_TAG="calendar-api-${{ steps.version.outputs.version }}"
          TAGS=""
          SHOULD_DEPLOY="false"
          ENVIRONMENT=""

          # Check if this is a PR
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"

            if [[ "$BASE_BRANCH" == "main" ]]; then
              # ANY PR to main - create ephemeral environment
              if [[ "$HEAD_BRANCH" == release/* ]]; then
                # Release PR to main gets special prerelease tag
                TAGS="${BASE_TAG}-prerelease,${BASE_TAG}-pr-${PR_NUMBER},pr-${PR_NUMBER}"
              else
                # Regular PR to main
                TAGS="${BASE_TAG}-pr-${PR_NUMBER},pr-${PR_NUMBER}"
              fi
              SHOULD_DEPLOY="true"
              ENVIRONMENT="pr-${PR_NUMBER}"
            elif [[ "$BASE_BRANCH" == release/* ]]; then
              # PR to release branch
              TAGS="${BASE_TAG}-dev"
            else
              # PR to other branches
              TAGS="${BASE_TAG}-pr-${PR_NUMBER}"
            fi
          else
            # Push to branch
            BRANCH="${{ github.ref_name }}"

            if [[ "$BRANCH" == "main" ]]; then
              # Push to main (after merge)
              TAGS="${BASE_TAG},latest"
              SHOULD_DEPLOY="true"
              ENVIRONMENT="prod"
            elif [[ "$BRANCH" == release/* ]]; then
              # Push to release branch - determine RC number
              RC_NUM=1
              if command -v aws &> /dev/null; then
                # Query ECR for existing RC tags for this version
                EXISTING_TAGS=$(aws ecr list-images --repository-name ${{ env.ECR_REPOSITORY }} \
                  --filter tagStatus=TAGGED \
                  --query "imageIds[?contains(imageTag, '${BASE_TAG}-rc')].imageTag" \
                  --output text 2>/dev/null || echo "")

                if [[ -n "$EXISTING_TAGS" ]]; then
                  # Extract RC numbers and find the highest
                  HIGHEST_RC=$(echo "$EXISTING_TAGS" | grep -oE "${BASE_TAG}-rc[0-9]+" |
                    sed "s/${BASE_TAG}-rc//" | sort -n | tail -1)
                  if [[ -n "$HIGHEST_RC" ]]; then
                    RC_NUM=$((HIGHEST_RC + 1))
                  fi
                fi
              fi

              TAGS="${BASE_TAG}-rc${RC_NUM}"
              SHOULD_DEPLOY="true"
              ENVIRONMENT="staging"
            elif [[ "$BRANCH" == "develop" ]]; then
              # Push to develop
              TAGS="${BASE_TAG}-dev"
              SHOULD_DEPLOY="true"
              ENVIRONMENT="dev"
            else
              # Other branches
              TAGS="${BASE_TAG}-dev"
            fi
          fi

          echo "Tags determined: $TAGS"
          echo "Should deploy: $SHOULD_DEPLOY"
          echo "Environment: $ENVIRONMENT"

          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

  build-and-push:
    name: Build and Push to ECR
    runs-on: ubuntu-latest
    needs: determine-tag
    if: needs.determine-tag.outputs.tags != ''

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.determine-tag.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ needs.determine-tag.outputs.version }}

      - name: Create deployment artifact
        if: needs.determine-tag.outputs.should_deploy == 'true'
        run: |
          echo '{
            "image": "${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.determine-tag.outputs.tags }}",
            "environment": "${{ needs.determine-tag.outputs.environment }}",
            "version": "${{ needs.determine-tag.outputs.version }}",
            "commit": "${{ github.sha }}"
          }' > deployment.json

      - name: Upload deployment artifact
        if: needs.determine-tag.outputs.should_deploy == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: deployment.json
          retention-days: 7

      - name: Comment on PR with image details
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.issue.number;
            const registry = '${{ steps.login-ecr.outputs.registry }}';
            const repository = '${{ env.ECR_REPOSITORY }}';
            const tags = '${{ needs.determine-tag.outputs.tags }}'.split(',');
            const aws_region = '${{ env.AWS_REGION }}';
            const aws_account = registry.split('.')[0];

            // Delete previous comments from this workflow
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            const botComments = comments.filter(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('🐳 Docker Image Published to ECR')
            );

            for (const comment of botComments) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: comment.id
              });
            }

            // Build comment body
            let body = '## 🐳 Docker Image Published to ECR\n\n';
            body += '**Registry:** `' + registry + '`\n';
            body += '**Repository:** `' + repository + '`\n';
            body += '**Tags:** ' + tags.map(tag => '`' + tag + '`').join(', ') + '\n\n';

            body += '### Full Image URIs:\n';
            for (const tag of tags) {
              body += '```\n' + registry + '/' + repository + ':' + tag + '\n```\n';
            }

            body += '\n### Pull Commands:\n';
            body += 'First, authenticate with ECR:\n';
            body += '```bash\n';
            body += 'aws ecr get-login-password --region ' + aws_region + ' | docker login --username AWS --password-stdin ' + registry + '\n';
            body += '```\n\n';

            body += 'Then pull the image:\n';
            for (const tag of tags) {
              body += '```bash\n';
              body += 'docker pull ' + registry + '/' + repository + ':' + tag + '\n';
              body += '```\n';
            }

            body += '\n### Run Locally:\n';
            body += '```bash\n';
            body += '# Example with environment variables\n';
            body += 'docker run -p 8000:8000 \\\n';
            body += '  -e DATABASE_URL="postgresql://user:pass@host:5432/db" \\\n';
            body += '  ' + registry + '/' + repository + ':' + tags[0] + '\n';
            body += '```\n';

            if ('${{ needs.determine-tag.outputs.should_deploy }}' === 'true') {
              body += '\n### 🚀 Deployment\n';
              body += 'This image will be automatically deployed to the **`' + '${{ needs.determine-tag.outputs.environment }}' + '`** environment.\n';
            }

            body += '\n---\n';
            body += '_Built from commit: ' + context.sha.substring(0, 7) + '_\n';

            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              body: body
            });

  trigger-deployment:
    name: Trigger Deployment
    runs-on: ubuntu-latest
    needs: [determine-tag, build-and-push]
    if: needs.determine-tag.outputs.should_deploy == 'true'

    steps:
      - name: Trigger deployment workflow
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd.yml',
              ref: context.ref,
              inputs: {
                environment: '${{ needs.determine-tag.outputs.environment }}',
                image_tag: '${{ needs.determine-tag.outputs.tags }}',
                version: '${{ needs.determine-tag.outputs.version }}'
              }
            });
