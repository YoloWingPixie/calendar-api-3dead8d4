name: Build and Deploy

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main]
  push:
    branches: [main, develop, release/*]

permissions:
  contents: read
  pull-requests: write
  id-token: write
  actions: write
  deployments: write

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: calendar-api
  AWS_ROLE_ARN: arn:aws:iam::655593807337:role/github-actions-calendar-api

jobs:
  # Wait for CI workflow to complete on PRs
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Wait for CI workflow
        uses: lewagon/wait-on-check-action@v1.3.4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          running-workflow-name: 'CI'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10
          allowed-conclusions: success

  # Determine tags and whether to deploy
  determine-strategy:
    name: Determine Build Strategy
    runs-on: ubuntu-latest
    needs: [wait-for-ci]
    if: always() && (needs.wait-for-ci.result == 'success' || needs.wait-for-ci.result == 'skipped')
    outputs:
      tags: ${{ steps.tags.outputs.tags }}
      version: ${{ steps.version.outputs.version }}
      should_deploy: ${{ steps.tags.outputs.should_deploy }}
      environment: ${{ steps.tags.outputs.environment }}
      image_uri: ${{ steps.tags.outputs.image_uri }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials for ECR query
        if: contains(github.ref, 'release/') || (github.event_name == 'push' && contains(github.ref, 'release/'))
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Extract version from pyproject.toml
        id: version
        run: |
          VERSION=$(grep -E '^version = ".*"$' pyproject.toml | sed 's/version = "\(.*\)"/\1/')
          echo "Version found: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Determine tags and deployment
        id: tags
        run: |
          BASE_TAG="calendar-api-${{ steps.version.outputs.version }}"
          TAGS=""
          SHOULD_DEPLOY="false"
          ENVIRONMENT=""

          # Check if this is a PR
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"

            if [[ "$BASE_BRANCH" == "main" ]]; then
              # ANY PR to main - create ephemeral environment
              if [[ "$HEAD_BRANCH" == release/* ]]; then
                # Release PR to main gets special prerelease tag
                TAGS="${BASE_TAG}-prerelease,${BASE_TAG}-pr-${PR_NUMBER},pr-${PR_NUMBER}"
              else
                # Regular PR to main
                TAGS="${BASE_TAG}-pr-${PR_NUMBER},pr-${PR_NUMBER}"
              fi
              SHOULD_DEPLOY="true"
              ENVIRONMENT="pr-${PR_NUMBER}"
            fi
          else
            # Push to branch
            BRANCH="${{ github.ref_name }}"

            if [[ "$BRANCH" == "main" ]]; then
              # Push to main (after merge)
              TAGS="${BASE_TAG},latest"
              SHOULD_DEPLOY="true"
              ENVIRONMENT="prod"
            elif [[ "$BRANCH" == release/* ]]; then
              # Push to release branch - determine RC number
              RC_NUM=1
              if command -v aws &> /dev/null; then
                # Query ECR for existing RC tags for this version
                EXISTING_TAGS=$(aws ecr list-images --repository-name ${{ env.ECR_REPOSITORY }} \
                  --filter tagStatus=TAGGED \
                  --query "imageIds[?contains(imageTag, '${BASE_TAG}-rc')].imageTag" \
                  --output text 2>/dev/null || echo "")

                if [[ -n "$EXISTING_TAGS" ]]; then
                  # Extract RC numbers and find the highest
                  HIGHEST_RC=$(echo "$EXISTING_TAGS" | grep -oE "${BASE_TAG}-rc[0-9]+" |
                    sed "s/${BASE_TAG}-rc//" | sort -n | tail -1)
                  if [[ -n "$HIGHEST_RC" ]]; then
                    RC_NUM=$((HIGHEST_RC + 1))
                  fi
                fi
              fi

              TAGS="${BASE_TAG}-rc${RC_NUM}"
              SHOULD_DEPLOY="true"
              ENVIRONMENT="staging"
            elif [[ "$BRANCH" == "develop" ]]; then
              # Push to develop
              TAGS="${BASE_TAG}-dev"
              SHOULD_DEPLOY="true"
              ENVIRONMENT="dev"
            fi
          fi

          echo "Tags determined: $TAGS"
          echo "Should deploy: $SHOULD_DEPLOY"
          echo "Environment: $ENVIRONMENT"

          # Set the first tag as primary for image URI
          PRIMARY_TAG=$(echo $TAGS | cut -d',' -f1)
          echo "image_uri=655593807337.dkr.ecr.us-east-1.amazonaws.com/${{ env.ECR_REPOSITORY }}:${PRIMARY_TAG}" >> $GITHUB_OUTPUT
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

  # Build and push Docker image
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: determine-strategy
    if: needs.determine-strategy.outputs.tags != ''

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.determine-strategy.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ needs.determine-strategy.outputs.version }}

      - name: Comment on PR with image details
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.issue.number;
            const registry = '${{ steps.login-ecr.outputs.registry }}';
            const repository = '${{ env.ECR_REPOSITORY }}';
            const tags = '${{ needs.determine-strategy.outputs.tags }}'.split(',');
            const aws_region = '${{ env.AWS_REGION }}';

            // Delete previous comments from this workflow
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            const botComments = comments.filter(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('ðŸ³ Docker Image Published to ECR')
            );

            for (const comment of botComments) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: comment.id
              });
            }

            // Build comment body
            let body = '## ðŸ³ Docker Image Published to ECR\n\n';
            body += '**Registry:** `' + registry + '`\n';
            body += '**Repository:** `' + repository + '`\n';
            body += '**Tags:** ' + tags.map(tag => '`' + tag + '`').join(', ') + '\n\n';

            body += '### Full Image URIs:\n';
            for (const tag of tags) {
              body += '```\n' + registry + '/' + repository + ':' + tag + '\n```\n';
            }

            body += '\n### Pull Commands:\n';
            body += 'First, authenticate with ECR:\n';
            body += '```bash\n';
            body += 'aws ecr get-login-password --region ' + aws_region + ' | docker login --username AWS --password-stdin ' + registry + '\n';
            body += '```\n\n';

            body += 'Then pull the image:\n';
            for (const tag of tags) {
              body += '```bash\n';
              body += 'docker pull ' + registry + '/' + repository + ':' + tag + '\n';
              body += '```\n';
            }

            body += '\n---\n';
            body += '_Built from commit: ' + context.sha.substring(0, 7) + '_\n';

            if ('${{ needs.determine-strategy.outputs.should_deploy }}' === 'true') {
              body += '\nðŸš€ **Deployment will begin shortly to environment: `${{ needs.determine-strategy.outputs.environment }}`**\n';
            }

            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              body: body
            });

  # Deploy to environment
  deploy:
    name: Deploy to ${{ needs.determine-strategy.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-strategy, build]
    if: needs.determine-strategy.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-strategy.outputs.environment }}
    env:
      TF_VERSION: 1.5.7

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Deploy
        working-directory: terraform
        run: |
          # Initialize with appropriate state file
          terraform init \
            -backend-config="key=calendar-api/${{ needs.determine-strategy.outputs.environment }}/terraform.tfstate"

          # Plan with variables
          terraform plan \
            -var="environment=${{ needs.determine-strategy.outputs.environment }}" \
            -var="doppler_token=${{ secrets.DOPPLER_TOKEN }}" \
            -var="docker_image_tag=${{ needs.determine-strategy.outputs.tags }}" \
            -var="is_ephemeral=${{ startsWith(needs.determine-strategy.outputs.environment, 'pr-') }}" \
            -out=tfplan

          # Apply
          terraform apply -auto-approve tfplan

      - name: Force ECS deployment
        run: |
          CLUSTER_NAME="calendar-api-${{ needs.determine-strategy.outputs.environment }}"
          SERVICE_NAME="calendar-api"

          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --force-new-deployment

          echo "Waiting for deployment to stabilize..."
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME

      - name: Get deployment info and comment on PR
        if: github.event_name == 'pull_request'
        run: |
          CLUSTER_NAME="calendar-api-${{ needs.determine-strategy.outputs.environment }}"

          # Get ALB DNS
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names "calendar-api-${{ needs.determine-strategy.outputs.environment }}" \
            --query "LoadBalancers[0].DNSName" \
            --output text 2>/dev/null || echo "")

          echo "alb_dns=$ALB_DNS" >> $GITHUB_ENV

      - name: Comment deployment details on PR
        if: github.event_name == 'pull_request' && env.alb_dns != ''
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.issue.number;
            const alb_dns = '${{ env.alb_dns }}';
            const environment = '${{ needs.determine-strategy.outputs.environment }}';

            // Delete previous deployment comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            const botComments = comments.filter(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('ðŸš€ Deployment Complete!')
            );

            for (const comment of botComments) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: comment.id
              });
            }

            let body = '## ðŸš€ Deployment Complete!\n\n';
            body += '**Environment:** `' + environment + '`\n';
            body += '**API Endpoint:** http://' + alb_dns + '\n\n';
            body += '### Quick Test:\n';
            body += '```bash\n';
            body += 'curl http://' + alb_dns + '/api/v1/health\n';
            body += '```\n\n';
            body += '---\n';
            body += '_This is an ephemeral environment that will be destroyed when the PR is closed._';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              body: body
            });
